<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Compression · LEGEND Data Format Specifications</title><meta name="title" content="Data Compression · LEGEND Data Format Specifications"/><meta property="og:title" content="Data Compression · LEGEND Data Format Specifications"/><meta property="twitter:title" content="Data Compression · LEGEND Data Format Specifications"/><meta name="description" content="Documentation for LEGEND Data Format Specifications."/><meta property="og:description" content="Documentation for LEGEND Data Format Specifications."/><meta property="twitter:description" content="Documentation for LEGEND Data Format Specifications."/><meta property="og:url" content="https://legend-exp.github.io/legend-data-format-specs/stable/data_compression/"/><meta property="twitter:url" content="https://legend-exp.github.io/legend-data-format-specs/stable/data_compression/"/><link rel="canonical" href="https://legend-exp.github.io/legend-data-format-specs/stable/data_compression/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="LEGEND Data Format Specifications logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="LEGEND Data Format Specifications logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LEGEND Data Format Specifications</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../hdf5/">HDF5</a></li><li><a class="tocitem" href="../metadata/">Metadata</a></li><li><a class="tocitem" href="../daq_data/">DAQ Data</a></li><li class="is-active"><a class="tocitem" href>Data Compression</a><ul class="internal"><li><a class="tocitem" href="#Lossless-compression-of-integer-valued-waveform-vectors"><span>Lossless compression of integer-valued waveform vectors</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Data Compression</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data Compression</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/legend-exp/legend-data-format-specs" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/legend-exp/legend-data-format-specs/blob/main/docs/src/data_compression.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Compression"><a class="docs-heading-anchor" href="#Data-Compression">Data Compression</a><a id="Data-Compression-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Compression" title="Permalink"></a></h1><p>In addition to compression features provided by standard data formats (HDF5, etc.), LEGEND data uses some custom data compression.</p><p>In the interest of long-term data accessibility and to ensure compliance with <a href="https://www.nature.com/articles/sdata201618">FAIR data principles</a>, use of custom data compression methods has to be limited to a minimum number of methods and use cases. Long-term use is only acceptable if:</p><ul><li>The custom compression significantly outperforms standard compression methods in compression ratio and/or (de-)compression speed for important use cases.</li><li>A complete formal description of the algorithms exists and is made publicly available under a license that allows for independent third-party implementations.</li><li>Verified implementations exist in a least two different programming languages, at least one of which has been implemented independently from the formal description of the algorithm and at least one of which is made publicly available under an open-source license.</li></ul><h2 id="Lossless-compression-of-integer-valued-waveform-vectors"><a class="docs-heading-anchor" href="#Lossless-compression-of-integer-valued-waveform-vectors">Lossless compression of integer-valued waveform vectors</a><a id="Lossless-compression-of-integer-valued-waveform-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Lossless-compression-of-integer-valued-waveform-vectors" title="Permalink"></a></h2><p>As detector waveforms have specific shapes, custom compression algorithms optimized for this use case can show a much higher speed/throughput than generic compression algorithms, at similar compression ratios.</p><p>Currently, we use the following custom integer-waveform compression algorithms:</p><table><tr><th style="text-align: right">Algorithm</th><th style="text-align: right">Identifier (<code>codec</code> attribute)</th></tr><tr><td style="text-align: right"><a href="#radware-sigcompress-v1.0">radware-sigcompress v1.0</a></td><td style="text-align: right"><code>radware_sigcompress</code></td></tr><tr><td style="text-align: right"><a href="#ULEB128-ZigZag-Differences">ULEB128 ZigZag Differences</a></td><td style="text-align: right"><code>uleb128_zigzag_diff</code></td></tr></table><p>Other compression algorithms are being developed, tested and evaluated.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The algorithm(s) in use are still subject to change, long-term data compatibility is not guaranteed at this point.</p></div></div><h3 id="ULEB128-ZigZag-Differences"><a class="docs-heading-anchor" href="#ULEB128-ZigZag-Differences">ULEB128 ZigZag Differences</a><a id="ULEB128-ZigZag-Differences-1"></a><a class="docs-heading-anchor-permalink" href="#ULEB128-ZigZag-Differences" title="Permalink"></a></h3><p>Efficient encoding of FADC waveform data can be achieved with the following algorithm:</p><ol><li>Compute the waveform derivative (differences between adjacent samples). Prepend the result with the first value of the original waveform</li><li>Map to positive values (including zero) via ZigZag encoding<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup></li><li>Compute a binary variable-length representation of each value via Unsigned Little Endian Base-128 (7-bit) encoding<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</li></ol><h3 id="radware-sigcompress-v1.0"><a class="docs-heading-anchor" href="#radware-sigcompress-v1.0">radware-sigcompress v1.0</a><a id="radware-sigcompress-v1.0-1"></a><a class="docs-heading-anchor-permalink" href="#radware-sigcompress-v1.0" title="Permalink"></a></h3><p>There is no formal description of the <em>radware-sigcompress</em> algorithm yet, so the C-code of the original implementation (<code>sigcompress.c</code>) will serve as the reference for now:</p><pre><code class="language-C hljs">// radware-sigcompress, v1.0
//
// This code is licensed under the MIT License (MIT).
// Copyright (c) 2018, David C. Radford &lt;radforddc@ornl.gov&gt;

#include &quot;stdio.h&quot;

int compress_signal(short *sig_in, unsigned short *sig_out, int sig_len_in) {

  int i, j, max1, max2, min1, min2, ds, nb1, nb2;
  int iso, nw, bp, dd1, dd2;
  unsigned short db[2];
  unsigned int *dd = (unsigned int *)db;
  static unsigned short mask[17] = {0,    1,    3,     7,     15,   31,
                                    63,   127,  255,   511,   1023, 2047,
                                    4095, 8191, 16383, 32767, 65535};

  // static int len[17] = {4096, 2048,512,256,128, 128,128,128,128,
  //                       128,128,128,128, 48,48,48,48};
  /* ------------ do compression of signal ------------ */
  j = iso = bp = 0;

  sig_out[iso++] = sig_len_in; // signal length
  while (j &lt; sig_len_in) {     // j = starting index of section of signal
    // find optimal method and length for compression of next section of signal
    max1 = min1 = sig_in[j];
    max2 = -16000;
    min2 = 16000;
    nb1 = nb2 = 2;
    nw = 1;
    for (i = j + 1; i &lt; sig_len_in &amp;&amp; i &lt; j + 48;
         i++) { // FIXME; # 48 could be tuned better?
      if (max1 &lt; sig_in[i])
        max1 = sig_in[i];
      if (min1 &gt; sig_in[i])
        min1 = sig_in[i];
      ds = sig_in[i] - sig_in[i - 1];
      if (max2 &lt; ds)
        max2 = ds;
      if (min2 &gt; ds)
        min2 = ds;
      nw++;
    }
    if (max1 - min1 &lt;= max2 - min2) { // use absolute values
      nb2 = 99;
      while (max1 - min1 &gt; mask[nb1])
        nb1++;
      // for (; i &lt; sig_len_in &amp;&amp; i &lt; j+len[nb1]; i++) {
      for (; i &lt; sig_len_in &amp;&amp; i &lt; j + 128;
           i++) { // FIXME; # 128 could be tuned better?
        if (max1 &lt; sig_in[i])
          max1 = sig_in[i];
        dd1 = max1 - min1;
        if (min1 &gt; sig_in[i])
          dd1 = max1 - sig_in[i];
        if (dd1 &gt; mask[nb1])
          break;
        if (min1 &gt; sig_in[i])
          min1 = sig_in[i];
        nw++;
      }
    } else { // use difference values
      nb1 = 99;
      while (max2 - min2 &gt; mask[nb2])
        nb2++;
      // for (; i &lt; sig_len_in &amp;&amp; i &lt; j+len[nb1]; i++) {
      for (; i &lt; sig_len_in &amp;&amp; i &lt; j + 128;
           i++) { // FIXME; # 128 could be tuned better?
        ds = sig_in[i] - sig_in[i - 1];
        if (max2 &lt; ds)
          max2 = ds;
        dd2 = max2 - min2;
        if (min2 &gt; ds)
          dd2 = max2 - ds;
        if (dd2 &gt; mask[nb2])
          break;
        if (min2 &gt; ds)
          min2 = ds;
        nw++;
      }
    }

    if (bp &gt; 0)
      iso++;
    /*  -----  do actual compression  -----  */
    sig_out[iso++] = nw; // compressed signal data, first byte = # samples
    bp = 0;              // bit pointer
    if (nb1 &lt;= nb2) {
      /*  -----  encode absolute values  -----  */
      sig_out[iso++] = nb1;                  // # bits used for encoding
      sig_out[iso++] = (unsigned short)min1; // min value used for encoding
      for (i = iso; i &lt;= iso + nw * nb1 / 16; i++)
        sig_out[i] = 0;
      for (i = j; i &lt; j + nw; i++) {
        dd[0] = sig_in[i] - min1; // value to encode
        dd[0] = dd[0] &lt;&lt; (32 - bp - nb1);
        sig_out[iso] |= db[1];
        bp += nb1;
        if (bp &gt; 15) {
          sig_out[++iso] = db[0];
          bp -= 16;
        }
      }

    } else {
      /*  -----  encode derivative / difference values  -----  */
      sig_out[iso++] = nb2 + 32; // # bits used for encoding, plus flag
      sig_out[iso++] = (unsigned short)sig_in[j]; // starting signal value
      sig_out[iso++] = (unsigned short)min2;      // min value used for encoding
      for (i = iso; i &lt;= iso + nw * nb2 / 16; i++)
        sig_out[i] = 0;
      for (i = j + 1; i &lt; j + nw; i++) {
        dd[0] = sig_in[i] - sig_in[i - 1] - min2; // value to encode
        dd[0] = dd[0] &lt;&lt; (32 - bp - nb2);
        sig_out[iso] |= db[1];
        bp += nb2;
        if (bp &gt; 15) {
          sig_out[++iso] = db[0];
          bp -= 16;
        }
      }
    }
    j += nw;
  }

  if (bp &gt; 0)
    iso++;
  if (iso % 2)
    iso++;    // make sure iso is even for 4-byte padding
  return iso; // number of shorts in compressed signal data

} /* compress_signal */

int decompress_signal(unsigned short *sig_in, short *sig_out, int sig_len_in) {

  int i, j, min, nb, isi, iso, nw, bp, siglen;
  unsigned short db[2];
  unsigned int *dd = (unsigned int *)db;
  static unsigned short mask[17] = {0,    1,    3,     7,     15,   31,
                                    63,   127,  255,   511,   1023, 2047,
                                    4095, 8191, 16383, 32767, 65535};

  /* ------------ do decompression of signal ------------ */
  j = isi = iso = bp = 0;
  siglen = (short)sig_in[isi++]; // signal length
  // printf(&quot;&lt;&lt;&lt; siglen = %d\n&quot;, siglen);
  for (i = 0; i &lt; 2048; i++)
    sig_out[i] = 0;
  while (isi &lt; sig_len_in &amp;&amp; iso &lt; siglen) {
    if (bp &gt; 0)
      isi++;
    bp = 0;             // bit pointer
    nw = sig_in[isi++]; // number of samples encoded in this chunk
    nb = sig_in[isi++]; // number of bits used in compression

    if (nb &lt; 32) {
      /*  -----  decode absolute values  -----  */
      min = (short)sig_in[isi++]; // min value used for encoding
      db[0] = sig_in[isi];
      for (i = 0; i &lt; nw &amp;&amp; iso &lt; siglen; i++) {
        if (bp + nb &gt; 15) {
          bp -= 16;
          db[1] = sig_in[isi++];
          db[0] = sig_in[isi];
          dd[0] = dd[0] &lt;&lt; (bp + nb);
        } else {
          dd[0] = dd[0] &lt;&lt; nb;
        }
        sig_out[iso++] = (db[1] &amp; mask[nb]) + min;
        bp += nb;
      }

    } else {
      nb -= 32;
      /*  -----  decode derivative / difference values  -----  */
      sig_out[iso++] = (short)sig_in[isi++]; // starting signal value
      min = (short)sig_in[isi++];            // min value used for encoding
      db[0] = sig_in[isi];
      for (i = 1; i &lt; nw &amp;&amp; iso &lt; siglen; i++) {
        if (bp + nb &gt; 15) {
          bp -= 16;
          db[1] = sig_in[isi++];
          db[0] = sig_in[isi];
          dd[0] = dd[0] &lt;&lt; (bp + nb);
        } else {
          dd[0] = dd[0] &lt;&lt; nb;
        }
        sig_out[iso] = (db[1] &amp; mask[nb]) + min + sig_out[iso - 1];
        iso++;
        bp += nb;
      }
    }
    j += nw;
  }

  if (siglen != iso) {
    printf(&quot;ERROR in decompress_signal: iso (%d ) != siglen (%d)!\n&quot;, iso,
           siglen);
  }
  return siglen; // number of shorts in decompressed signal data

} /* decompress_signal */</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding">https://wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding</a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><a href="https://wikipedia.org/wiki/LEB128#Unsigned_LEB128">https://wikipedia.org/wiki/LEB128#Unsigned_LEB128</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../daq_data/">« DAQ Data</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Wednesday 12 February 2025 13:34">Wednesday 12 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
