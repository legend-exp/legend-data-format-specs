<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Data Compression · LEGEND Data Format Specifications</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://legend-exp.github.io/legend-data-format-specs/stable/data_compression/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">LEGEND Data Format Specifications</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../hdf5/">HDF5</a></li><li class="is-active"><a class="tocitem" href>Data Compression</a><ul class="internal"><li><a class="tocitem" href="#Lossless-compression-of-integer-valued-waveform-vectors"><span>Lossless compression of integer-valued waveform vectors</span></a></li></ul></li><li><a class="tocitem" href="../daq_data/">DAQ Data</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Data Compression</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Data Compression</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/legend-exp/legend-data-format-specs/blob/main/docs/src/data_compression.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Data-Compression"><a class="docs-heading-anchor" href="#Data-Compression">Data Compression</a><a id="Data-Compression-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Compression" title="Permalink"></a></h1><p>In addition to compression features provided by standard data formats (HDF5, etc.), LEGEND data uses some custom data compression.</p><p>In the interest of long-term data accessibility and to ensure compliance with FAIR data principles, use of custom data compression methods has to be limited to a minimum number of methods and use cases. Long-term use is only acceptable if:</p><ul><li><p>The custom compression significantly outperforms standard compression methods in compression ratio and/or (de-)compression speed for important use cases.</p></li><li><p>A complete formal description of the algorithms exists and is made publicly available under a license that allows for independent third-party implementations.</p></li><li><p>Verified implementations exist in a least two different programming languages, at least one of which has been implemented independently from the formal description of the algorithm and at least one of which is made publicly available under an open-source license.</p></li></ul><h2 id="Lossless-compression-of-integer-valued-waveform-vectors"><a class="docs-heading-anchor" href="#Lossless-compression-of-integer-valued-waveform-vectors">Lossless compression of integer-valued waveform vectors</a><a id="Lossless-compression-of-integer-valued-waveform-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Lossless-compression-of-integer-valued-waveform-vectors" title="Permalink"></a></h2><p>As detector waveforms have specific shapes, custom compression algorithms optimized for this use case can show a much higher speed/throughput than generic compression algorithms, at similar compression ratios.</p><p>Currently, we use the following custom integer-waveform compression algorithms:</p><ul><li>radware-sigcompress v1.0</li></ul><p>Other compression algorithms are being developed, tested and evaluated.</p><p>Note: The algorithm(s) in use are still subject to change, long-term data compatibility is not guaranteed at this point.</p><h3 id="radware-sigcompress"><a class="docs-heading-anchor" href="#radware-sigcompress">radware-sigcompress</a><a id="radware-sigcompress-1"></a><a class="docs-heading-anchor-permalink" href="#radware-sigcompress" title="Permalink"></a></h3><p>There is no formal description of the radware-sigcompress algorithm yet, so the C-code of the original implementation (&quot;sigcompress.c&quot;) will serve as the reference for now:</p><pre><code class="language-C hljs">// radware-sigcompress, v1.0
//
// This code is licensed under the MIT License (MIT).
// Copyright (c) 2018, David C. Radford &lt;radforddc@ornl.gov&gt;

int compress_signal(short *sig_in, unsigned short *sig_out, int sig_len_in) {

  int   i, j, max1, max2, min1, min2, ds, nb1, nb2;
  int   iso, nw, bp, dd1, dd2;
  unsigned short db[2];
  unsigned int   *dd = (unsigned int *) db;
  static unsigned short mask[17] = {0, 1,3,7,15, 31,63,127,255,
                                    511,1023,2047,4095, 8191,16383,32767,65535};

  //static int len[17] = {4096, 2048,512,256,128, 128,128,128,128,
  //                      128,128,128,128, 48,48,48,48};
  /* ------------ do compression of signal ------------ */
  j = iso = bp = 0;

  sig_out[iso++] = sig_len_in;     // signal length
  while (j &lt; sig_len_in) {         // j = starting index of section of signal
    // find optimal method and length for compression of next section of signal 
    max1 = min1 = sig_in[j];
    max2 = -16000;
    min2 = 16000;
    nb1 = nb2 = 2;
    nw = 1;
    for (i=j+1; i &lt; sig_len_in &amp;&amp; i &lt; j+48; i++) { // FIXME; # 48 could be tuned better?
      if (max1 &lt; sig_in[i]) max1 = sig_in[i];
      if (min1 &gt; sig_in[i]) min1 = sig_in[i];
      ds = sig_in[i] - sig_in[i-1];
      if (max2 &lt; ds) max2 = ds;
      if (min2 &gt; ds) min2 = ds;
        nw++;
    }
    if (max1-min1 &lt;= max2-min2) { // use absolute values
      nb2 = 99;
      while (max1 - min1 &gt; mask[nb1]) nb1++;
      //for (; i &lt; sig_len_in &amp;&amp; i &lt; j+len[nb1]; i++) {
      for (; i &lt; sig_len_in &amp;&amp; i &lt; j+128; i++) { // FIXME; # 128 could be tuned better?
        if (max1 &lt; sig_in[i]) max1 = sig_in[i];
        dd1 = max1 - min1;
        if (min1 &gt; sig_in[i]) dd1 = max1 - sig_in[i];
        if (dd1 &gt; mask[nb1]) break;
        if (min1 &gt; sig_in[i]) min1 = sig_in[i];
        nw++;
      }
    } else {                      // use difference values
      nb1 = 99;
      while (max2 - min2 &gt; mask[nb2]) nb2++;
      //for (; i &lt; sig_len_in &amp;&amp; i &lt; j+len[nb1]; i++) {
      for (; i &lt; sig_len_in &amp;&amp; i &lt; j+128; i++) { // FIXME; # 128 could be tuned better?
        ds = sig_in[i] - sig_in[i-1];
        if (max2 &lt; ds) max2 = ds;
        dd2 = max2 - min2;
        if (min2 &gt; ds) dd2 = max2 - ds;
        if (dd2 &gt; mask[nb2]) break;
        if (min2 &gt; ds) min2 = ds;
        nw++;
      }
    }

    if (bp &gt; 0) iso++;
    /*  -----  do actual compression  -----  */
    sig_out[iso++] = nw;  // compressed signal data, first byte = # samples
    bp = 0;               // bit pointer
    if (nb1 &lt;= nb2) {
      /*  -----  encode absolute values  -----  */
      sig_out[iso++] = nb1;                    // # bits used for encoding
      sig_out[iso++] = (unsigned short) min1;  // min value used for encoding
      for (i = iso; i &lt;= iso + nw*nb1/16; i++) sig_out[i] = 0;
      for (i = j; i &lt; j + nw; i++) {
        dd[0] = sig_in[i] - min1;              // value to encode
        dd[0] = dd[0] &lt;&lt; (32 - bp - nb1);
        sig_out[iso] |= db[1];
        bp += nb1;
        if (bp &gt; 15) {
          sig_out[++iso] = db[0];
          bp -= 16;
        }
      }

    } else {
      /*  -----  encode derivative / difference values  -----  */
      sig_out[iso++] = nb2 + 32;  // # bits used for encoding, plus flag
      sig_out[iso++] = (unsigned short) sig_in[j];  // starting signal value
      sig_out[iso++] = (unsigned short) min2;       // min value used for encoding
      for (i = iso; i &lt;= iso + nw*nb2/16; i++) sig_out[i] = 0;
      for (i = j+1; i &lt; j + nw; i++) {
        dd[0] = sig_in[i] - sig_in[i-1] - min2;     // value to encode
        dd[0]= dd[0] &lt;&lt; (32 - bp - nb2);
        sig_out[iso] |= db[1];
        bp += nb2;
        if (bp &gt; 15) {
          sig_out[++iso] = db[0];
          bp -= 16;
        }
      }
    }
    j += nw;
  }

  if (bp &gt; 0) iso++;
  if (iso%2) iso++;     // make sure iso is even for 4-byte padding
  return iso;           // number of shorts in compressed signal data

} /* compress_signal */


int decompress_signal(unsigned short *sig_in, short *sig_out, int sig_len_in) {

  int   i, j, min, nb, isi, iso, nw, bp, siglen;
  unsigned short db[2];
  unsigned int   *dd = (unsigned int *) db;
  static unsigned short mask[17] = {0, 1,3,7,15, 31,63,127,255,
                                    511,1023,2047,4095, 8191,16383,32767,65535};

  /* ------------ do decompression of signal ------------ */
  j = isi = iso = bp = 0;
  siglen = (short) sig_in[isi++];  // signal length
  //printf(&quot;&lt;&lt;&lt; siglen = %d\n&quot;, siglen);
  for (i=0; i&lt;2048; i++) sig_out[i] = 0;
  while (isi &lt; sig_len_in &amp;&amp; iso &lt; siglen) {
    if (bp &gt; 0) isi++;
    bp = 0;              // bit pointer
    nw = sig_in[isi++];  // number of samples encoded in this chunk
    nb = sig_in[isi++];  // number of bits used in compression

    if (nb &lt; 32) {
      /*  -----  decode absolute values  -----  */
      min = (short) sig_in[isi++];  // min value used for encoding
      db[0] = sig_in[isi];
      for (i = 0; i &lt; nw &amp;&amp; iso &lt; siglen; i++) {
        if (bp+nb &gt; 15) {
          bp -= 16;
          db[1] = sig_in[isi++];
          db[0] = sig_in[isi];
          dd[0] = dd[0] &lt;&lt; (bp+nb);
        } else {
          dd[0] = dd[0] &lt;&lt; nb;
        }
        sig_out[iso++] = (db[1] &amp; mask[nb]) + min;
        bp += nb;
      }

    } else {
      nb -= 32;
      /*  -----  decode derivative / difference values  -----  */
      sig_out[iso++] = (short) sig_in[isi++];  // starting signal value
      min = (short) sig_in[isi++];             // min value used for encoding
      db[0] = sig_in[isi];
      for (i = 1; i &lt; nw &amp;&amp; iso &lt; siglen; i++) {
        if (bp+nb &gt; 15) {
          bp -= 16;
          db[1] = sig_in[isi++];
          db[0] = sig_in[isi];
          dd[0] = dd[0] &lt;&lt; (bp+nb);
        } else {
          dd[0] = dd[0] &lt;&lt; nb;
        }
        sig_out[iso] = (db[1] &amp; mask[nb]) + min + sig_out[iso-1]; iso++;
        bp += nb;
      }
    }
    j += nw;
  }

  if (siglen != iso) {
    printf(&quot;ERROR in decompress_signal: iso (%d ) != siglen (%d)!\n&quot;,
           iso, siglen);
  }
  return siglen;       // number of shorts in decompressed signal data

} /* decompress_signal */</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../hdf5/">« HDF5</a><a class="docs-footer-nextpage" href="../daq_data/">DAQ Data »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 28 March 2023 09:33">Tuesday 28 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
